#+title: Emacs Config
#+options: toc:nil num:nil
#+property: header-args :tangle yes

This is my personal Emacs setup. There are many like it, but this one is mine.

* Emacs Settings

Let Emacs put changes made via custom in a separate file.

#+begin_src elisp
  (setq custom-file (concat user-emacs-directory "custom.el"))
  (when (file-exists-p custom-file)
    (load custom-file))
#+end_src

Disable some distracting UI elements.

#+begin_src elisp
  (push '(tool-bar-lines . 0)       default-frame-alist)
  (push '(vertical-scroll-bars . 0) default-frame-alist)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (blink-cursor-mode -1)
#+end_src

But do enable some others

#+begin_src elisp
  (add-hook 'prog-mode-hook 'hl-line-mode)
  (add-hook 'text-mode-hook 'hl-line-mode)
#+end_src

Let's start in fullscreen.

#+begin_src elisp
  (set-frame-parameter (selected-frame) 'fullscreen 'maximized)
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

Some sensible defaults.

#+begin_src elisp
  (prefer-coding-system 'utf-8)

  (setq-default delete-by-moving-to-trash t
                fill-column 80)

  (setq inhibit-startup-screen t
        frame-resize-pixelwise t
        window-resize-pixelwise t
        scroll-conservatively 101
        scroll-margin 5)

  (setq use-short-answers t
        require-final-newline t)

  (global-set-key (kbd "<escape>") #'keyboard-escape-quit)
  (global-set-key (kbd "C-+") #'text-scale-increase)
  (global-set-key (kbd "C--") #'text-scale-decrease)
#+end_src

Cleanup empty lines at the end of a file upon saving.

#+begin_src elisp
  (defun ls/delete-trailing-newlines ()
    "Trim trailing newlines.

  Function lifted from Doom Emacs"
    (interactive)
    (save-excursion
      (goto-char (point-max))
      (delete-blank-lines)))

  (add-hook 'before-save-hook 'ls/delete-trailing-newlines)
#+end_src

Change Emacs' archaic backup behavior. Your colleagues will thank you...maybe.

#+begin_src elisp
  (setq create-lockfiles nil
        make-backup-files nil)

  (setq auto-save-default t
        auto-save-include-big-deletions t
        auto-save-list-file-prefix (concat user-emacs-directory "autosave/"))
#+end_src

When splitting a window, prefer to split vertically.

#+begin_src elisp
  (setq split-width-threshold 160
        split-height-threshold nil)
#+end_src

Set a nice font.

#+begin_src elisp
  (set-face-attribute 'default nil
                      :family "DejaVu Sans Mono Nerd Font"
                      :height 105
                      :weight 'normal)
#+end_src

* Package Setup

We need packages to make Emacs better. And to make installing and configuring packages easy I use =use-package=.

#+begin_src elisp
  (require 'package)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (setq use-package-always-ensure t
        use-package-compute-statistics t)
#+end_src

* Core

Let's first install and configure some packages that I really cannot do without.

** Evil

Evil is a vim emulation layer for Emacs. Emacs' default keybindings hurt my hands, vim's do not.

#+begin_src elisp
  (use-package evil
    :after undo-fu
    :init
    (setq evil-want-keybinding nil
          evil-undo-system 'undo-fu
          evil-backspace-join-lines t
          evil-respect-visual-line-mode t)
    :config
    (evil-global-set-key 'motion "j" 'evil-next-visual-line)
    (evil-global-set-key 'motion "k" 'evil-previous-visual-line)
    (evil-global-set-key 'motion "H" 'evil-beginning-of-visual-line)
    (evil-global-set-key 'motion "L" 'evil-end-of-visual-line)
    (evil-mode t))

  (use-package evil-collection
    :after evil
    :config
    (setq evil-collection-setup-minibuffer t)
    (evil-collection-init))

  (use-package undo-fu)

  (use-package evil-nerd-commenter
    :bind ("C-/" . evilnc-comment-or-uncomment-lines))

  (use-package evil-vimish-fold
    :hook (prog-mode . evil-vimish-fold-mode))
#+end_src

** Ace Window

Window navigation commands kind of suck. Ace window does not suck.

#+begin_src elisp
(use-package ace-window
  :bind ("M-o" . ace-window)
  :config (setq ace-window-display-mode t))
#+end_src

** Projectile

While recent versions of Emacs come with tools to manage and navigate projects, they are not as powerful as projectile (yet).

#+begin_src elisp
  (use-package projectile
    :bind
    ("C-c p" . projectile-command-map)
    :config
    (setq projectile-switch-project-action #'consult-projectile))
#+end_src

** Which Key

Sometimes I forget what the keybindings do. Having Emacs show it to me is very helpful.

#+begin_src elisp
  (use-package which-key
    :config
    (setq which-key-sort-order #'which-key-key-order-alpha
          which-key-add-column-padding 20
          which-key-idle-delay 0.2)
    (which-key-setup-side-window-bottom)
    (which-key-mode))
#+end_src

* Minibuffer Completion

There are many minibuffer completion frameworks, and they're all pretty great. Current selection is vertico. Add in some marginalia and consult, and you have a powerful but lightweight completion system, as well as a myriad of useful commands.

#+begin_src elisp
  (use-package vertico
    :bind (:map vertico-map
                (("C-j" . vertico-next)
                 ("C-k" . vertico-previous)
                 ("C-o" . vertico-next-group)))
    :config
    (setq vertico-count 25
          vertico-resize 'grow-only)
    (vertico-multiform-mode t)
    (vertico-mode t))

  (use-package vertico-directory
    :after vertico
    :ensure nil
    :bind (:map vertico-map
                ("RET" . vertico-directory-enter)
                ("C-l" . vertico-directory-delete-word)
                ("C-d" . vertico-directory-enter))
    :hook (rfn-eshadow-update-overlay . vertico-directory-tidy))

  (use-package vertico-prescient
    :config (vertico-prescient-mode))

  (use-package marginalia
    :after vertico
    :init (marginalia-mode))

  (use-package consult
    :after (evil vertico)
    :bind (:map evil-normal-state-map
                ("C-s"   . consult-line)
                ("C-c i" . consult-imenu)
                ("/"     . consult-ripgrep))
    :config
    (setq consult-line-start-from-top t)
    (setq vertico-multiform-categories '((consult-grep buffer))))

  (use-package consult-projectile
    :after projectile
    :bind (:map projectile-command-map
                ("h" . consult-projectile)))
#+end_src

* In-buffer Completion

What editor is complete without the ability to provide suggestions as you type them?

#+begin_src elisp
  (use-package corfu
    :config (setq corfu-auto-delay 0.1
                  corfu-auto t
                  corfu-cycle nil
                  corfu-bar-width 0.4
                  corfu-min-width 20
                  corfu-left-margin-width 2
                  corfu-right-margin-width 2)
    :hook (prog-mode . corfu-mode))

  (use-package cape
    :init
    (add-to-list 'completion-at-point-functions #'cape-file))

  (use-package kind-icon
    :after corfu
    :config
    (setq kind-icon-default-face 'corfu-default)
    (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))
#+end_src

* UI

Emacs looks pretty dated out-of-the-box. But with some packages we can spice it up a lot.

** Theme

Nothing changes as often as my preferred theme. Luckily there's a whole lot to choose from.

#+begin_src elisp
  (use-package doom-themes
    :config
    (setq doom-themes-enable-bold t
          doom-themes-enable-italic t)
    (load-theme 'doom-gruvbox-light t))

  (use-package solaire-mode
    :after doom-themes
    :config (solaire-global-mode))
#+end_src

** Modeline

The default modeline is very informative...and ugly. I really do not need all this information, so I prefer to use a more stripped-down modeline.

#+begin_src elisp
  (use-package telephone-line
    :config
    (setq telephone-line-height 25
          telephone-line-evil-use-short-tag t
          telephone-line-primary-left-separator telephone-line-flat
          telephone-line-primary-right-separator telephone-line-flat
          telephone-line-secondary-left-separator telephone-line-flat
          telephone-line-secondary-right-separator telephone-line-flat)
    (telephone-line-mode))
#+end_src

In some modes we do not want to see the modeline at all.

#+begin_src elisp
  (use-package hide-mode-line
    :defer t)
#+end_src

** Treemacs

Using Treemacs we can show a file browser like you'd find in VS Code, Atom, and other modern editors.

#+begin_src elisp
  (use-package treemacs
    :bind (("<f8>" . treemacs)
           ("S-<f8>" . treemacs-select-window))
    :config
    (doom-themes-treemacs-config)
    (setq doom-themes-treemacs-theme "doom-colors"
          doom-themes-treemacs-enable-variable-pitch nil))
#+end_src

** Window Lines

Add more window lines to better separate windows from one-another.

#+begin_src elisp
  (setq window-divider-default-places t
        window-divider-default-right-width 1
        window-divider-default-bottom-width 1)
  (window-divider-mode t)
#+end_src

** Dashboard

Emacs standard dashboard is kind of ugly. Let's use something a bit nicer looking.

#+begin_src elisp
  (use-package dashboard
    :config
    (setq dashboard-banner-logo-title nil
          dashboard-center-content t
          dashboard-items '((recents . 5)
                            (projects . 5)))
    (dashboard-setup-startup-hook))
#+end_src

** Fringes

Increase the fringe width to give some breathing room.

#+begin_src elisp
  (set-fringe-mode 24)

  (setq-default fringes-outside-margins t)
#+end_src

A feature found in many modern editors and IDEs is showing version control information per line in the fringes, using different colors for new, updated, and deleted lines.

#+begin_src elisp
  (use-package diff-hl
    :defer t)

  (add-hook 'prog-mode-hook
            '(lambda ()
               (setq-local left-margin-width 0
                           right-margin-width 0
                           left-fringe-width 16
                           right-fringe-width 16)
               (diff-hl-mode)))
#+end_src

** All The Icons

Some packages want to show icons. These icons need to be installed first.

#+begin_src elisp
  (use-package all-the-icons
    :defer t)
#+end_src

* Programming

Programming in Emacs is a joy, but it requires some configuration. Let's start with settings applicable to all languages.

Use spaces instead of tabs. Spaces are more flexible, and the space saving benefits do not matter on modern machines. Use 4 spaces for tabs.

#+begin_src elisp
  (setq-default indent-tabs-mode nil
                tab-width 4)
#+end_src

But when working with others, you may have to deviate from your personal preferences. To codify the consensus regarding common editor configuration options, we have editorconfig

#+begin_src elisp
  (use-package editorconfig
    :config
    (setq editorconfig-trim-whitespaces-mode 'ws-butler-mode)
    (editorconfig-mode 1))
#+end_src

Show line numbers and use color pairings for delimiters.

#+begin_src elisp
  (use-package display-line-numbers
    :ensure nil
    :hook (prog-mode . display-line-numbers-mode)
    :init
    (setq-default display-line-numbers-width 3
                  display-line-numbers-widen 'grow-only))

  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

Indicate empty lines.

#+begin_src elisp
  (add-hook 'prog-mode-hook (lambda () (setq-local indicate-empty-lines t)))
#+end_src

Indicate trailing whitespace and clean it up when saving.

#+begin_src elisp
  (add-hook 'prog-mode-hook
            (lambda () (setq-local show-trailing-whitespace t)))

  (use-package ws-butler
    :hook ((text-mode . ws-butler-mode)
           (prog-mode . ws-butler-mode))
    :config
    (setq ws-butler-keep-whitespace-before-point nil))
#+end_src

Highlight text that goes past the fill-column marker (80 characters).

#+begin_src elisp
  (use-package column-enforce-mode
    :hook (prog-mode . column-enforce-mode))
#+end_src

Live feedback on your crap code.

#+begin_src elisp
  (use-package flycheck
    :hook (prog-mode . global-flycheck-mode)
    :config
    (setq flycheck-idle-change-delay 1.0
          flycheck-display-errors-delay 0.2
          flycheck-indication-mode 'right-fringe))

  (use-package flycheck-pos-tip
    :hook (flycheck-mode . flycheck-pos-tip-mode))
#+end_src

** Ruby

#+begin_src elisp
  (use-package ruby-electric
    :hook (ruby-mode . ruby-electric-mode))

  (use-package yard-mode
    :hook (ruby-mode . yard-mode))

  (use-package rvm
    :hook (ruby-mode . rvm-activate-corresponding-ruby))

  (use-package rspec-mode
    :defer t)
#+end_src

** YAML

#+begin_src elisp
  (use-package yaml-mode
    :defer t)
#+end_src

** PHP

I am unfortunate enough to sometimes program in PHP.

#+begin_src elisp
  (use-package php-mode
    :defer t)
#+end_src

* Writing

Emacs is not just suited for writing code. It's also a good prose editor. But, some tweaks have to be made again for a better experience.

#+begin_src elisp
  (setq sentence-end-double-space nil)

  (use-package visual-fill-column
    :hook (text-mode . visual-fill-column-mode))

  (setq-default fill-column 80)
  (add-hook 'text-mode-hook #'visual-line-mode)
#+end_src

** Org Mode

Org mode is a very powerful system for organizing things. I mostly use it as a more powerful alternative to markdown. At some point I will have to spend some time learning the more advanced features.

#+begin_src elisp
  (use-package org
    :ensure nil
    :hook (org-mode . org-indent-mode)
    :config
    (require 'org-tempo))

  (use-package org-superstar
    :hook (org-mode . org-superstar-mode)
    :config
    (setq org-superstar-headline-bullets-list '("â—‰")))
#+end_src

Occasionally I generate LaTeX documents from Org documents. These often have code snippets in them. By default, Org mode exports code snippets to listing environments. I don't like the look of these. I prefer to use =minted=.

#+begin_src elisp
  (use-package ox-latex
    :after org
    :ensure nil
    :config
    (setq org-latex-listings 'minted
          org-latex-minted-options '(("linenos" "true")))
    (add-to-list 'org-latex-packages-alist '("" "minted" t ("pdflatex")) t))
#+end_src

* Tools

At what point does an editor stop being an editor, and becomes much more? Right here.

** Dired

#+begin_src elisp
  (setq dired-auto-revert-buffer t
        dired-listing-switches "-la --group-directories-first")

  (use-package diredfl
    :hook (dired-mode . diredfl-mode))
#+end_src

** VTERM

The best terminal emulator available for Emacs.

#+begin_src elisp
  (use-package vterm
    :commands (vterm vterm-other-window)
    :bind ("C-S-t" . vterm-other-window)
    :hook (vterm-mode . hide-mode-line-mode)
    :config
    (setq vterm-timer-delay 0
          vterm-max-scrollback 10000
          vterm-kill-buffer-on-exit t))
#+end_src

** Magit

Magit is a /fantastic/ git client.

#+begin_src elisp
  (use-package magit
    :bind ("C-x g" . magit-status))
#+end_src

** PDF Tools

Being able to read PDFs within Emacs is a great feature, especially when editing LaTeX org Org documents.

#+begin_src elisp
  (use-package pdf-tools
    :mode ("\\.pdf\\'" . pdf-view-mode)
    :config
    (setq-default pdf-view-display-size 'fit-page)
    (setq pdf-view-use-scaling t
          pdf-view-use-imagemagick nil)
    (pdf-loader-install :noquery))
#+end_src

* Miscellaneous

Things I don't know where else to put

** Long lines

Current versions of Emacs are not good with handling (very) long lines, slowing down considerably. So-long mode does not quite fix, but with it enabled Emacs at least won't slow down to a complete halt when opening compiled JavaScript files.

#+begin_src elisp
  (add-hook 'after-init-hook  'global-so-long-mode)
#+end_src
