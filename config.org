#+title: Emacs Config
#+options: toc:nil num:nil
#+property: header-args :tangle yes
#+startup: overview

This is my personal Emacs setup. There are many like it, but this one is mine.

* General Emacs Settings

Load the environment settings.

#+begin_src elisp
  (defvar environment-file (concat user-emacs-directory "environment.el"))

  ;;; initialize user variables
  ;; fonts
  (defvar ls/fixed-pitch-font (font-spec :family "monospace" :size 14))
  (defvar ls/variable-pitch-font (font-spec :family "sans serif" :size 14))
  ;; theme
  (defvar ls/theme 'default)

  (when (file-exists-p environment-file)
    (load environment-file))
#+end_src

Let Emacs put changes made via custom in a separate file.

#+begin_src elisp
  (setq custom-file (concat user-emacs-directory "custom.el"))
  (when (file-exists-p custom-file)
    (load custom-file))
#+end_src

Disable some distracting UI elements.

#+begin_src elisp
  (push '(tool-bar-lines . 0)       default-frame-alist)
  (push '(vertical-scroll-bars . 0) default-frame-alist)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (blink-cursor-mode -1)
#+end_src

But do enable some others.

#+begin_src elisp
  (dolist (mode-hook '(prog-mode-hook text-mode-hook))
    (add-hook mode-hook 'hl-line-mode))
#+end_src

Let's start in fullscreen.

#+begin_src elisp
  (set-frame-parameter (selected-frame) 'fullscreen 'maximized)
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

Why use anything but unicode?

#+begin_src elisp
  (prefer-coding-system 'utf-8)
  (set-language-environment 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
#+end_src

Some sensible defaults.

#+begin_src elisp
  (setq-default delete-by-moving-to-trash t
                fill-column 80)

  (setq inhibit-startup-screen t
        frame-resize-pixelwise t
        window-resize-pixelwise t
        scroll-conservatively 101
        scroll-margin 5
        scroll-preserve-screen-position t
        auto-window-vscroll nil
        require-final-newline t
        completion-ignore-case t
        read-file-name-completion-ignore-case t
        ring-bell-function 'ignore)

  (defalias #'yes-or-no-p #'y-or-n-p)

  (global-set-key (kbd "<escape>") #'keyboard-escape-quit)
  (global-set-key (kbd "C-+") #'text-scale-increase)
  (global-set-key (kbd "C--") #'text-scale-decrease)
#+end_src

Auto revert is a must.

#+begin_src elisp
  (require 'autorevert)
  (setq auto-revert-verbose nil
        global-auto-revert-non-file-buffers t)
  (global-auto-revert-mode)
#+end_src

Cleanup empty lines at the end of a file upon saving.

#+begin_src elisp
  (defun ls/delete-trailing-newlines ()
    "Trim trailing newlines.

  Function lifted from Doom Emacs"
    (interactive)
    (save-excursion
      (goto-char (point-max))
      (delete-blank-lines)))

  (add-hook 'before-save-hook 'ls/delete-trailing-newlines)
#+end_src

Change Emacs' archaic backup behavior. Your colleagues will thank you...maybe.

#+begin_src elisp
  (setq create-lockfiles nil
        make-backup-files nil)

  (setq auto-save-default t
        auto-save-include-big-deletions t
        auto-save-list-file-prefix (concat user-emacs-directory "autosave/"))
#+end_src

When splitting a window, prefer to split vertically.

#+begin_src elisp
  (setq split-width-threshold 160
        split-height-threshold nil)
#+end_src

IMenu is a nice generic tool to quickly traverse over all major sections in your file, be they headers, class names, or methods. Like so many of Emacs' built-ins it needs a little tweaking to work nicely.

#+begin_src elisp
  (setq imenu-max-item-length 500)
#+end_src

Current versions of Emacs are not good with handling (very) long lines, slowing it down considerably. So-long mode does not quite fix these issues, but with it enabled Emacs at least won't slow down to a complete halt when opening compiled JavaScript files for example.

#+begin_src elisp
  (add-hook 'after-init-hook  'global-so-long-mode)
#+end_src

* Package Setup

We need packages to make Emacs better. And to make installing and configuring packages easy I use =use-package=.

#+begin_src elisp
  (setq-default straight-use-package-by-default t
                straight-cache-autoloads t
                straight-check-for-modifications nil)

  (defvar bootstrap-version)
  (let ((bootstrap-file
     (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
    (bootstrap-version 6))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
      (url-retrieve-synchronously
       "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
       'silent 'inhibit-cookies)
    (goto-char (point-max))
    (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  (straight-use-package 'use-package)

  (setq use-package-always-ensure t
        use-package-expand-minimally t
        use-package-compute-statistics t)
#+end_src

* Core

Let's configure some built-in Emacs packages and then install and configure some packages that I really cannot do without.

** Built-in

Auto insert mode lets you automatically insert content when opening new files. This is useful for inserting boilerplate code, for example.

#+begin_src elisp
  (setq auto-insert-query nil
        auto-insert-directory (concat user-emacs-directory "auto-insert")
        auto-insert-alist '((ruby-mode . "ruby.el")))
  (auto-insert-mode)
#+end_src

** Evil

Evil is a vim emulation layer for Emacs. Emacs' default keybindings hurt my hands, vim's do not.

#+begin_src elisp
  (use-package evil
    :after undo-fu
    :init
    (setq evil-want-keybinding nil
          evil-undo-system 'undo-fu
          evil-backspace-join-lines t
          evil-respect-visual-line-mode t)
    :config
    (evil-global-set-key 'motion "j" 'evil-next-visual-line)
    (evil-global-set-key 'motion "k" 'evil-previous-visual-line)
    (evil-global-set-key 'motion "H" 'evil-beginning-of-visual-line)
    (evil-global-set-key 'motion "L" 'evil-end-of-visual-line)
    (evil-mode t))

  (use-package evil-collection
    :after evil
    :config
    (setq evil-collection-setup-minibuffer t)
    (evil-collection-init))

  (use-package undo-fu)

  (use-package evil-nerd-commenter
    :bind ("C-/" . evilnc-comment-or-uncomment-lines))

  (use-package evil-vimish-fold
    :hook (prog-mode . evil-vimish-fold-mode))
#+end_src

** Ace Window

The default window navigation commands kind of suck. Ace window does not suck.

#+begin_src elisp
(use-package ace-window
  :bind ("M-o" . ace-window)
  :config (setq ace-window-display-mode t))
#+end_src

** Projectile

While recent versions of Emacs come with tools to manage and navigate projects, they are not as powerful as projectile (yet).

#+begin_src elisp
  (use-package projectile
    :bind-keymap
    ("C-c p" . projectile-command-map)
    :config
    (setq projectile-auto-discover t
          projectile-switch-project-action #'consult-projectile)
    (projectile-global-mode))
#+end_src

** Which Key

Sometimes I forget what the keybindings do. Having Emacs show it to me is very helpful.

#+begin_src elisp
  (use-package which-key
    :config
    (setq which-key-sort-order #'which-key-key-order-alpha
          which-key-add-column-padding 20
          which-key-idle-delay 0.2)
    (which-key-setup-side-window-bottom)
    (which-key-mode))
#+end_src

* Minibuffer Completion

There are many minibuffer completion frameworks, and they're all pretty great. Current selection is vertico. Add in some marginalia and consult, and you have a powerful but lightweight completion system, as well as a myriad of useful commands.

#+begin_src elisp
  (use-package vertico
    :straight (vertico :files ("*.el" "extensions/*.el")
                       :includes (vertico-directory vertico-multiform))
    :bind (:map vertico-map
                (("C-j" . vertico-next)
                 ("C-k" . vertico-previous)
                 ("C-o" . vertico-next-group)))
    :init
    (setq vertico-count 25
          vertico-resize 'grow-only)
    (vertico-multiform-mode t)
    (vertico-mode))

  (use-package vertico-directory
    :after vertico
    :ensure nil
    :bind (:map vertico-map
                ("RET" . vertico-directory-enter)
                ("C-l" . vertico-directory-delete-word)
                ("C-d" . vertico-directory-enter))
    :hook (rfn-eshadow-update-overlay . vertico-directory-tidy))

  (use-package vertico-prescient
    :after vertico
    :config (vertico-prescient-mode))

  (use-package marginalia
    :after vertico
    :init (marginalia-mode))

  (use-package consult
    :after (evil vertico)
    :bind (:map evil-normal-state-map
                ("C-s"   . consult-line)
                ("C-c i" . consult-imenu)
                ("/"     . consult-ripgrep)
                ("C-x b" . consult-buffer))
    :config
    (setq consult-line-start-from-top t
          consult-project-function #'projectile-project-root
          vertico-multiform-categories '((consult-grep buffer))))

  (use-package consult-projectile
    :after projectile
    :bind (:map projectile-command-map
                ("h" . consult-projectile)))
#+end_src

* In-buffer Completion

What editor is complete without the ability to provide suggestions as you type them?

#+begin_src elisp
  (use-package company
    :hook (prog-mode . company-mode)
    :config (setq company-idle-delay 0.1
                  company-minimum-prefix-length 3))

  (use-package company-posframe
    :hook (company-mode . company-posframe-mode)
    :config (setq company-posframe-show-indicator nil
                  company-posframe-show-params '((alpha . 10))
                  company-posframe-quickhelp-show-header nil))
#+end_src

* UI

Emacs looks pretty dated out-of-the-box. But with some packages we can spice it up a lot.

** Font

Set a nice font.

#+begin_src elisp
  (dolist (face '(default fixed-pitch fixed-pitch-serif))
    (set-face-attribute face nil
                        :weight 'normal
                        :width  'normal
                        :slant  'normal
                        :font   ls/fixed-pitch-font))

  (dolist (face '(variable-pitch))
    (set-face-attribute face nil
                        :weight 'normal
                        :width  'normal
                        :slant  'normal
                        :font   ls/variable-pitch-font))
#+end_src

** Theme

Nothing changes as often as my preferred theme. Luckily there's a whole lot to choose from.

#+begin_src elisp
  (use-package doom-themes
    :defer t
    :config
    (setq doom-themes-enable-bold t
          doom-themes-enable-italic t
          doom-themes-treemacs-theme "doom-atom")
    (doom-themes-treemacs-config)
    (doom-themes-org-config))

  (use-package spacemacs-theme
    :defer t)

  (use-package ef-themes
    :defer t)

  (use-package standard-themes
    :defer t)

  (use-package solaire-mode
    :after doom-themes
    :config (solaire-global-mode))

  (load-theme ls/theme t)
#+end_src

** Modeline

The default modeline is very informative...and ugly. I really do not need all this information, so I prefer to use a more stripped-down modeline.

#+begin_src elisp
  (use-package telephone-line
    :config
    (setq telephone-line-height 25
          telephone-line-evil-use-short-tag t
          telephone-line-primary-left-separator telephone-line-flat
          telephone-line-primary-right-separator telephone-line-flat
          telephone-line-secondary-left-separator telephone-line-flat
          telephone-line-secondary-right-separator telephone-line-flat)
    (telephone-line-mode))
#+end_src

In some modes we do not want to see the modeline at all.

#+begin_src elisp
  (use-package hide-mode-line
    :defer t)
#+end_src

** Treemacs

Using Treemacs we can show a file browser like you'd find in VS Code, Atom, and other modern editors.

#+begin_src elisp
  (use-package treemacs
    :hook (treemacs-mode . treemacs-project-follow-mode)
    :bind (("<f8>" . treemacs)
           ("S-<f8>" . treemacs-select-window))
    :config
    (doom-themes-treemacs-config)
    (setq doom-themes-treemacs-theme "doom-colors"
          doom-themes-treemacs-enable-variable-pitch t)
    (setq treemacs-is-never-other-window t
          treemacs-follow-after-init t
          treemacs-project-follow-cleanup t
          treemacs--project-follow-delay 0))

  (use-package treemacs-evil
    :after (treemacs evil))

  (use-package treemacs-projectile
    :after (treemacs projectile))

  (use-package treemacs-magit
    :after (treemacs magit))
#+end_src

** Window Lines

Add more window lines to better visually separate windows from one-another.

#+begin_src elisp
  (setq window-divider-default-places t
        window-divider-default-right-width 1
        window-divider-default-bottom-width 1)
  (window-divider-mode t)
#+end_src

** Dashboard

Emacs standard dashboard is kind of ugly. Let's use something a bit nicer looking.

#+begin_src elisp
  (use-package dashboard
    :config
    (setq dashboard-banner-logo-title nil
          dashboard-set-footer nil
          dashboard-center-content t
          dashboard-items '((recents . 5)
                            (projects . 5)))
    (dashboard-setup-startup-hook))
#+end_src

** Fringes

Increase the fringe width to give some breathing room.

#+begin_src elisp
  (set-fringe-mode 24)

  (setq-default fringes-outside-margins t)
#+end_src

A feature found in many modern editors and IDEs is showing version control information per line in the fringes, using different colors for new, updated, and deleted lines. We can add that feature with =diff-hl=.

#+begin_src elisp
  (use-package diff-hl
    :defer t)

  (add-hook 'prog-mode-hook
            (lambda ()
              (setq-local left-margin-width 0
                          right-margin-width 0
                          left-fringe-width 16
                          right-fringe-width 16)
              (diff-hl-mode)))
#+end_src

** All The Icons

Some packages want to show icons. These icons need to be installed first.

#+begin_src elisp
  (use-package all-the-icons
    :defer t)
#+end_src

* Programming

Programming in Emacs is a joy, but it requires some configuration. Let's start with settings applicable to all languages.

Use spaces instead of tabs. Spaces are more flexible, and the space saving benefits of using tabs do not matter on modern machines. Use 4 spaces for tabs by default. This can be overridden for specific modes.

#+begin_src elisp
  (setq-default indent-tabs-mode nil
                tab-width 4)
#+end_src

But when working with other people, you may have to deviate from your personal preferences. To codify the consensus regarding common editor configuration options, we have editorconfig.

#+begin_src elisp
  (use-package editorconfig
    :config
    (setq editorconfig-trim-whitespaces-mode 'ws-butler-mode)
    (editorconfig-mode 1))
#+end_src

Show line numbers and use color pairings for delimiters.

#+begin_src elisp
  (use-package display-line-numbers
    :straight (:type built-in)
    :hook (prog-mode . display-line-numbers-mode)
    :init
    (setq-default display-line-numbers-width 3
                  display-line-numbers-widen 'grow-only))

  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

Indicate empty lines.

#+begin_src elisp
  (add-hook 'prog-mode-hook (lambda () (setq-local indicate-empty-lines t)))
#+end_src

Indicate trailing whitespace and clean it up when saving.

#+begin_src elisp
  (add-hook 'prog-mode-hook
            (lambda () (setq-local show-trailing-whitespace t)))

  (use-package ws-butler
    :hook ((text-mode . ws-butler-mode)
           (prog-mode . ws-butler-mode))
    :config
    (setq ws-butler-keep-whitespace-before-point nil))
#+end_src

Highlight text that goes past the fill-column marker (80 characters).

#+begin_src elisp
  (use-package column-enforce-mode
    :hook (prog-mode . column-enforce-mode))
#+end_src

Get live feedback on your crap code.

#+begin_src elisp
  (use-package flycheck
    :hook (prog-mode . global-flycheck-mode)
    :config
    (setq flycheck-idle-change-delay 1.0
          flycheck-display-errors-delay 0.2
          flycheck-indication-mode 'right-fringe))

  (use-package flycheck-pos-tip
    :hook (flycheck-mode . flycheck-pos-tip-mode))
#+end_src

** Arduino

#+begin_src elisp
  (use-package arduino-mode)
#+end_src

** Ruby

#+begin_src elisp
  (use-package ruby-electric
    :hook (ruby-mode . ruby-electric-mode))

  (use-package yard-mode
    :hook (ruby-mode . yard-mode))

  (use-package rvm
    :hook (ruby-mode . rvm-activate-corresponding-ruby))

  (use-package rubocop
    :hook (ruby-mode . rubocop-mode)
    :config (setq rubocop-autocorrect-on-save t))

  (use-package rspec-mode
    :defer t)
#+end_src

** YAML

#+begin_src elisp
  (use-package yaml-mode
    :defer t)
#+end_src

** HAML

#+begin_src elisp
  (use-package haml-mode
    :mode ("\\.haml\\'" . haml-mode))
#+end_src

** PHP

I am unfortunate enough to sometimes program in PHP.

#+begin_src elisp
  (use-package php-mode
    :defer t)
#+end_src

** TypeScript

#+begin_src elisp
  (use-package typescript-mode
    :defer t)
#+end_src

** Coffeescript

#+begin_src elisp
  (use-package coffee-mode
    :defer t)
#+end_src

** Docker

#+begin_src elisp
  (use-package dockerfile-mode
    :defer t)
#+end_src

** Terraform

#+begin_src elisp
  (use-package terraform-mode
    :mode ("\\.tf\\'" . terraform-mode))
#+end_src

* Writing

Emacs is not just suited for writing code. It's also a good prose editor. But, some tweaks have to be made again for a better experience.

Sentences do not need to end with double spaces. That era is over.

#+begin_src elisp
  (setq sentence-end-double-space nil)
#+end_src

In most text modes I prefer to use soft breaks, meaning that the text is visually wrapped at the fill-column mark, but underneath no real newline is inserted. However, in some modes this behavior is undesirable. So let's define a method that determines whether this behavior should be on or off depending on whether the current major mode is an exception or not.

#+begin_src elisp
  (use-package visual-fill-column
    :hook (text-mode . ls/turn-on-visual-fill-column-mode-maybe)
    :init
    (defun ls/turn-on-visual-fill-column-mode-maybe ()
      (let ((exceptions '(yaml-mode nxml-mode)))
        (unless (apply 'derived-mode-p exceptions)
          (visual-line-mode +1)
          (visual-fill-column-mode +1)))))
#+end_src

** Org Mode

Org mode is a very powerful system for organizing things. I mostly use it as a more powerful alternative to markdown. At some point I will have to spend some time learning the more advanced features.

#+begin_src elisp
  (use-package org
    :straight (:type built-in)
    :hook (org-mode . org-indent-mode)
    :config
    (require 'org-tempo))

  (use-package org-superstar
    :hook (org-mode . org-superstar-mode)
    :config
    (setq org-superstar-headline-bullets-list '("â—‰")))
#+end_src

Occasionally I generate LaTeX documents from Org documents. These often have code snippets in them. By default, Org mode exports code snippets to listing environments. I don't like the look of these. I prefer to use =minted=.

#+begin_src elisp
  (use-package ox-latex
    :straight (:type built-in)
    :after org
    :config
    (setq org-latex-listings 'minted
          org-latex-minted-options '(("linenos" "true")))
    (add-to-list 'org-latex-packages-alist '("" "minted" t ("pdflatex")) t))
#+end_src

** Markdown

It's everywhere.

#+begin_src elisp
  (use-package markdown-mode
    :mode ("README\\.md\\'" . gfm-mode))
#+end_src

* Tools

At what point does an editor stop being an editor, and becomes much more? Right here.

** Dired

#+begin_src elisp
  (setq dired-auto-revert-buffer t
        dired-listing-switches "-la --group-directories-first")

  (use-package diredfl
    :hook (dired-mode . diredfl-mode))
#+end_src

** VTERM

The best terminal emulator available for Emacs.

#+begin_src elisp
  (use-package vterm
    :commands (vterm vterm-other-window)
    :bind ("C-S-t" . vterm-other-window)
    :hook (vterm-mode . hide-mode-line-mode)
    :config
    (setq vterm-timer-delay 0
          vterm-max-scrollback 10000
          vterm-kill-buffer-on-exit t))
#+end_src

** Magit

Magit is a /fantastic/ git client.

#+begin_src elisp
  (use-package magit
    :bind ("C-x g" . magit-status))
#+end_src

** PDF Tools

Being able to read PDFs within Emacs is a great feature, especially when editing LaTeX org Org documents.

#+begin_src elisp
  (use-package pdf-tools
    :mode ("\\.pdf\\'" . pdf-view-mode)
    :config
    (setq-default pdf-view-display-size 'fit-page)
    (setq pdf-view-use-scaling t
          pdf-view-use-imagemagick nil)
    (pdf-loader-install :noquery))
#+end_src
